数组：
1. 【easy】面试题03. 数组中重复的数字 https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/ （使用数组原地置换的方法，很精妙）
2. 【easy】面试题04. 二维数组中的查找 https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/ （找到数据的规律）

链表：
1. 【esay】面试题24. 反转链表 https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/ （基础）
2. 【easy】面试题18. 删除链表的节点 https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/
3. 【easy】141. 环形链表 https://leetcode-cn.com/problems/linked-list-cycle/
4. 【middle】142. 环形链表 II https://leetcode-cn.com/problems/linked-list-cycle-ii/
5. 【easy】面试题22. 链表中倒数第k个节点 https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/
6. 【easy】面试题25. 合并两个排序的链表 https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/
7. 【easy】面试题52. 两个链表的第一个公共节点 https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/


栈：
1. 【easy】155. 最小栈 https://leetcode-cn.com/problems/min-stack/
2. 【easy】716. 最大栈 https://leetcode-cn.com/problems/max-stack/

二分查找：
1. 【easy】69. x 的平方根 https://leetcode-cn.com/problems/sqrtx/
2. 

滑动窗口：
1. 【middle】3. 无重复字符的最长子串 https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/

双指针：
1. 【easy】面试题05. 替换空格 https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/（不使用stringBuilder实现：双指针从后往前依次复制）
2. 【middle】3. 无重复字符的最长子串 https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/
3. 

动态规划：
1. 【easy】70. 爬楼梯 https://leetcode-cn.com/problems/climbing-stairs/
2. 【easy】53. 最大子序和 https://leetcode-cn.com/problems/maximum-subarray/

贪心算法：
1. 【hard】45. 跳跃游戏 II https://leetcode-cn.com/problems/jump-game-ii/

典型递归：
1. 【middle】50. Pow(x, n) https://leetcode-cn.com/problems/powx-n/

回溯算法：
1. 【middle】17. 电话号码的字母组合 https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/
2. 【middle】22. 括号生成 https://leetcode-cn.com/problems/generate-parentheses/
3. 【middle】78. 子集 https://leetcode-cn.com/problems/subsets/
4. 【middle】433. 最小基因变化 https://leetcode-cn.com/problems/minimum-genetic-mutation/
5. 【middle】529. 扫雷游戏 https://leetcode-cn.com/problems/minesweeper/
6. 【hard】51. N皇后 https://leetcode-cn.com/problems/n-queens/  ( 技巧： pie 的坐标是 row + col , na 的坐标是 row - col)

贪心算法：
1. 【very easy】860. 柠檬水找零 https://leetcode-cn.com/problems/lemonade-change/ 
2. 【easy】455. 分发饼干 https://leetcode-cn.com/problems/assign-cookies/
3. 【middle】55. 跳跃游戏 https://leetcode-cn.com/problems/jump-game/
4. 【easy】122. 买卖股票的最佳时机 II https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/
5. 【hard】45. 跳跃游戏 II https://leetcode-cn.com/problems/jump-game-ii/

买卖股票系列：
1. 【easy】122. 买卖股票的最佳时机 II https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/

单词接龙：
1. 【middle】433. 最小基因变化 https://leetcode-cn.com/problems/minimum-genetic-mutation/

二叉搜索树：
1. 【middle】98. 验证二叉搜索树 https://leetcode-cn.com/problems/validate-binary-search-tree/
2. 【middle】面试题36. 二叉搜索树与双向链表 https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/
3. 【middle】面试题07. 重建二叉树 https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/

二叉树层序遍历：
1. 【middle】102. 二叉树的层序遍历 https://leetcode-cn.com/problems/binary-tree-level-order-traversal/#/description

二叉树路径问题：
1. 【easy（伪easy，有hard难度感觉）】687. 最长同值路径 https://leetcode-cn.com/problems/longest-univalue-path/
2. 【hard】124. 二叉树中的最大路径和 https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/

二叉树同值比较类型题目：
1. 【middle】面试题26. 树的子结构 https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/
2. 【easy】572. 另一个树的子树 https://leetcode-cn.com/problems/subtree-of-another-tree/
3. 【easy】687. 最长同值路径 https://leetcode-cn.com/problems/longest-univalue-path/
4. 【middle】250. 统计同值子树 https://leetcode-cn.com/problems/count-univalue-subtrees/

拓扑排序：
1. 【middle】210. 课程表 II https://leetcode-cn.com/problems/course-schedule-ii/
2. 【middle】207. 课程表 https://leetcode-cn.com/problems/course-schedule/
3. 

摩尔投票法：
1. 【easy】169. 多数元素 https://leetcode-cn.com/problems/majority-element/

##### 每一个系列序号，按照推荐做题顺序排列

```text
递归代码模版：
public void recursion(level, param1, param2,...){
    // recursion terminator
    if (level > MAX_LEVEL){
        process_result
        return
    }
    
    //process logic in current level
    process(level, data...)
    
    //drill down
    recursion(level+1, p1, p2...);
    
    //revert the current level status if needed
}

分治代码模版：
public void divide_conquer(problem, param1, param2,...) {
    // recursion terminator
    if(problem is None){
        print_result
        return        
    }
    // prepare data
    data = prepare_data(problem);
    subproblems = split_problem(problem, data);
    // conquer subproblems
    subresult1 = divide_conquer(subproblems[0], p1,...);
    subresult2 = divide_conquer(subproblems[1], p1,...);
    subresult3 = divide_conquer(subproblems[2], p1,...);
    ...
    
    //process and generate the final result
    result = process_result(subresult1, subresult2, subresult3, …)

    // revert the current level status
}

回溯算法模版：
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
        
深度优先搜索模版：
def dfs(node):
    if node in visited:   
        #already visited
        return
    visited.add(node)
    #process current node
    # logic here
    dfs(node.left)
    dfs(node.right)

广度优先搜索模版：
def bfs(graph, start, end):
    queue=[]
    queue.add([start])
    visited.add(start)
    while queue:
        node = queue.pop()
        visited.add(node)
        process(node)
        nodes = generate_related_nodes(node)
        queue.push(nodes)
    #other processing work
```