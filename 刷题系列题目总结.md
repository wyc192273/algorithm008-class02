滑动窗口：
1. 【middle】3. 无重复字符的最长子串 https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/

双指针：
1. 【middle】3. 无重复字符的最长子串 https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/

动态规划：
1. 【easy】70. 爬楼梯 https://leetcode-cn.com/problems/climbing-stairs/
2. 【easy】53. 最大子序和 https://leetcode-cn.com/problems/maximum-subarray/

贪心算法：
1. 【hard】45. 跳跃游戏 II https://leetcode-cn.com/problems/jump-game-ii/

典型递归：
1. 【middle】50. Pow(x, n) https://leetcode-cn.com/problems/powx-n/

回溯算法：
1. 【middle】17. 电话号码的字母组合 https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/
2. 【middle】22. 括号生成 https://leetcode-cn.com/problems/generate-parentheses/
3. 【middle】78. 子集 https://leetcode-cn.com/problems/subsets/
4. 【middle】433. 最小基因变化 https://leetcode-cn.com/problems/minimum-genetic-mutation/
5. 【middle】529. 扫雷游戏 https://leetcode-cn.com/problems/minesweeper/
6. 【hard】51. N皇后 https://leetcode-cn.com/problems/n-queens/  ( 技巧： pie 的坐标是 row + col , na 的坐标是 row - col)

贪心算法：
1. 【very easy】860. 柠檬水找零 https://leetcode-cn.com/problems/lemonade-change/ 
2. 【easy】455. 分发饼干 https://leetcode-cn.com/problems/assign-cookies/
3. 【middle】55. 跳跃游戏 https://leetcode-cn.com/problems/jump-game/
4. 【hard】45. 跳跃游戏 II https://leetcode-cn.com/problems/jump-game-ii/

单词接龙：
1. 【middle】433. 最小基因变化 https://leetcode-cn.com/problems/minimum-genetic-mutation/

二叉搜索树：
1. 【middle】98. 验证二叉搜索树 https://leetcode-cn.com/problems/validate-binary-search-tree/

二叉树层序遍历：
1. 【middle】102. 二叉树的层序遍历 https://leetcode-cn.com/problems/binary-tree-level-order-traversal/#/description

二叉树路径问题：
1. 【easy（伪easy，有hard难度感觉）】687. 最长同值路径 https://leetcode-cn.com/problems/longest-univalue-path/
2. 【hard】124. 二叉树中的最大路径和 https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/

二叉树同值比较类型题目：
1. 【easy】572. 另一个树的子树 https://leetcode-cn.com/problems/subtree-of-another-tree/
2. 【middle】250. 统计同值子树 https://leetcode-cn.com/problems/count-univalue-subtrees/

摩尔投票法：
1. 【easy】169. 多数元素 https://leetcode-cn.com/problems/majority-element/

##### 每一个系列序号，按照推荐做题顺序排列

```text
递归代码模版：
public void recursion(level, param1, param2,...){
    // recursion terminator
    if (level > MAX_LEVEL){
        process_result
        return
    }
    
    //process logic in current level
    process(level, data...)
    
    //drill down
    recursion(level+1, p1, p2...);
    
    //revert the current level status if needed
}

分治代码模版：
public void divide_conquer(problem, param1, param2,...) {
    // recursion terminator
    if(problem is None){
        print_result
        return        
    }
    // prepare data
    data = prepare_data(problem);
    subproblems = split_problem(problem, data);
    // conquer subproblems
    subresult1 = divide_conquer(subproblems[0], p1,...);
    subresult2 = divide_conquer(subproblems[1], p1,...);
    subresult3 = divide_conquer(subproblems[2], p1,...);
    ...
    
    //process and generate the final result
    result = process_result(subresult1, subresult2, subresult3, …)

    // revert the current level status
}

回溯算法模版：
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
        
深度优先搜索模版：
def dfs(node):
    if node in visited:   
        #already visited
        return
    visited.add(node)
    #process current node
    # logic here
    dfs(node.left)
    dfs(node.right)

广度优先搜索模版：
def bfs(graph, start, end):
    queue=[]
    queue.add([start])
    visited.add(start)
    while queue:
        node = queue.pop()
        visited.add(node)
        process(node)
        nodes = generate_related_nodes(node)
        queue.push(nodes)
    #other processing work
```